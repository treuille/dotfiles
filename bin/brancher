#!/usr/bin/env bash
#
# brancher - Manage parallel working directories tied to Git branches
#
# USAGE:
#   brancher open <branch_name>  - Create new branch and workspace, cd into it
#   brancher sync                - Bidirectionally sync with parent branch
#   brancher close               - Merge back, cleanup, cd to parent repo
#
# SHELL WRAPPER REQUIREMENT:
#   This script outputs "cd '/path'" to stdout for directory changes.
#   To actually change directories, you need a shell wrapper function.
#   Add this to your .zshrc or .bashrc:
#
#     brancher() {
#         local output
#         output="$(${HOME}/dotfiles/bin/brancher "$@")"
#         local rc=$?
#         if [[ $rc -eq 0 && "$output" == cd\ * ]]; then
#             eval "$output"
#         elif [[ -n "$output" ]]; then
#             echo "$output"
#         fi
#         return $rc
#     }
#
#   Without this wrapper, you'll see the cd command printed but won't
#   actually change directories.
#

set -euo pipefail

# ------------------------------------------------------------------------------
# Helper functions
# ------------------------------------------------------------------------------

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
RESET='\033[0m'

info() {
    echo -e "${BLUE}▸${RESET} $*" >&2
}

success() {
    echo -e "${GREEN}✓${RESET} $*" >&2
}

warn() {
    echo -e "${YELLOW}⚠${RESET} $*" >&2
}

die() {
    echo -e "${RED}✗ Error:${RESET} $*" >&2
    exit 1
}

# Run a git command with stdout redirected to stderr (prevents polluting cd output)
# Usage: git_safe <git args...>
# Usage: git_safe -C <dir> <git args...>
git_safe() {
    git "$@" >&2
}

# Run a git command with stdout to stderr, stderr hidden
# Use for commands where we want user to see success output but not errors
# Usage: git_quiet <git args...>
git_quiet() {
    git "$@" >&2 2>/dev/null
}

# Run a git command completely silently (all output hidden)
# Use for cleanup operations where we don't need any output
# Usage: git_silent <git args...>
git_silent() {
    git "$@" >/dev/null 2>&1
}

usage() {
    cat >&2 <<'EOF'
Usage:
  brancher open <branch_name>
  brancher sync
  brancher close

Description:
  brancher open  - Create a new Git branch and a parallel workspace directory.
  brancher sync  - Pull latest parent branch changes into the workspace branch.
  brancher close - Sync, merge branch back to parent, delete branch and workspace.

Notes:
  - Run 'brancher open' from the Git repo root.
  - Run 'brancher sync' and 'brancher close' from inside the branch workspace.
EOF
    exit 1
}

# Check if we are inside a Git repository
require_git_repo() {
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        die "not inside a Git repository."
    fi
}

# Get the absolute path of a directory
abs_path() {
    (cd "$1" && pwd)
}

# Check if a directory has uncommitted changes (staged or unstaged)
# Untracked files are ignored. Returns 0 (true) if dirty.
has_uncommitted_changes() {
    local dir="${1:-.}"
    [[ -n "$(git -C "$dir" status --porcelain 2>/dev/null | grep -v '^??')" ]]
}

# Rename tmux pane title if inside tmux (errors are ignored)
tmux_set_pane_title() {
    local title="$1"
    if [[ -n "${TMUX:-}" ]] && command -v tmux >/dev/null 2>&1; then
        tmux select-pane -T "$title" 2>/dev/null || true
    fi
}

# Output cd command for the shell wrapper to eval
output_cd() {
    echo "cd '$1'"
}

# Require that we are in a brancher workspace and parse metadata
# Sets global variables: WORKSPACE_ROOT, PARENT_REPO_ROOT, PARENT_BRANCH, BRANCH_NAME, START_COMMIT
require_brancher_workspace() {
    require_git_repo

    WORKSPACE_ROOT="$(git rev-parse --show-toplevel)"

    local meta_file="$WORKSPACE_ROOT/.brancher-meta"
    if [[ ! -f "$meta_file" ]]; then
        die "this does not look like a brancher workspace (missing .brancher-meta)."
    fi

    # Parse metadata
    PARENT_REPO_ROOT=""
    PARENT_BRANCH=""
    BRANCH_NAME=""
    START_COMMIT=""
    while IFS='=' read -r key value; do
        case "$key" in
            parent_repo_root) PARENT_REPO_ROOT="$value" ;;
            parent_branch) PARENT_BRANCH="$value" ;;
            branch_name) BRANCH_NAME="$value" ;;
            start_commit) START_COMMIT="$value" ;;
        esac
    done < "$meta_file"

    if [[ -z "$PARENT_REPO_ROOT" || -z "$PARENT_BRANCH" || -z "$BRANCH_NAME" || -z "$START_COMMIT" ]]; then
        die "malformed .brancher-meta file."
    fi

    # Check current branch matches expected branch
    local current_branch
    current_branch="$(git rev-parse --abbrev-ref HEAD)"
    if [[ "$current_branch" != "$BRANCH_NAME" ]]; then
        die "current branch '$current_branch' does not match expected branch '$BRANCH_NAME'."
    fi

    # Check if parent repo exists
    if [[ ! -d "$PARENT_REPO_ROOT" ]]; then
        die "parent repo '$PARENT_REPO_ROOT' does not exist."
    fi
}

# ------------------------------------------------------------------------------
# brancher open
# ------------------------------------------------------------------------------

do_open() {
    local branch_name="${1:-}"

    # Validate arguments
    if [[ -z "$branch_name" ]]; then
        echo "Error: missing branch name." >&2
        usage
    fi

    # Validate we are inside a Git repository
    require_git_repo

    # Get repo root and check we are at it
    local repo_root
    repo_root="$(git rev-parse --show-toplevel)"

    if [[ "$PWD" != "$repo_root" ]]; then
        die "brancher open must be run from the Git repo root."
    fi

    # Determine names and paths
    local repo_name
    repo_name="$(basename "$repo_root")"
    local parent_branch
    parent_branch="$(git rev-parse --abbrev-ref HEAD)"
    local start_commit
    start_commit="$(git rev-parse HEAD)"

    # Compute parallel directory path (absolute)
    local parallel_dir
    parallel_dir="$(abs_path "$repo_root/..")/${repo_name}_${branch_name}"

    # Precondition checks
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
        die "Git branch '$branch_name' already exists."
    fi

    if [[ -e "$parallel_dir" ]]; then
        die "workspace directory '$parallel_dir' already exists."
    fi

    # Create the new branch (without switching to it)
    if ! git_safe branch "$branch_name"; then
        die "failed to create branch '$branch_name'."
    fi

    # Create the parallel directory using git worktree
    if ! git_quiet worktree add "$parallel_dir" "$branch_name"; then
        # Clean up the branch we just created
        git_silent branch -D "$branch_name" || true
        die "failed to create worktree at '$parallel_dir'."
    fi

    # Create metadata file in the new workspace
    local meta_file="$parallel_dir/.brancher-meta"
    cat > "$meta_file" <<EOF
parent_repo_root=$repo_root
parent_branch=$parent_branch
branch_name=$branch_name
start_commit=$start_commit
EOF

    # Add .brancher-meta to gitignore (worktrees share the main repo's info/exclude)
    local git_common_dir
    git_common_dir="$(git -C "$parallel_dir" rev-parse --git-common-dir)"
    if ! grep -qxF ".brancher-meta" "$git_common_dir/info/exclude" 2>/dev/null; then
        echo ".brancher-meta" >> "$git_common_dir/info/exclude"
    fi

    # tmux: rename pane to branch name
    tmux_set_pane_title "$branch_name"

    # User feedback
    success "Created branch ${CYAN}${branch_name}${RESET} from ${CYAN}${parent_branch}${RESET}"
    info "Workspace: ${BOLD}${parallel_dir}${RESET}"

    # Output cd command
    output_cd "$parallel_dir"
}

# ------------------------------------------------------------------------------
# brancher sync
# ------------------------------------------------------------------------------
#
# WHAT SYNC DOES:
#   Bidirectionally synchronizes the current branch with its parent branch.
#   After sync, both branches point to the same commit and both worktrees
#   reflect all changes from both branches.
#
# WORKFLOW:
#   1. Pre-validation (no changes made):
#      - Check current workspace is clean
#      - Check parent worktree is clean
#      - Check merge would succeed (no conflicts)
#
#   2. Sync (if validation passes):
#      a. Merge parent → current (get parent's changes)
#      b. Fast-forward parent to current (give parent our changes)
#      c. Update parent worktree to reflect merged state
#
# EXAMPLE:
#   You're in repo_test_01 (branch: test_01, parent: katha_v2)
#   - katha_v2 has commits A, B
#   - test_01 has commits A, B, C, D (your work)
#
#   After sync:
#   - Both test_01 and katha_v2 point to commit D
#   - repo_katha_v2 directory now has commits C, D
#   - repo_test_01 directory unchanged (already had everything)
#
# ------------------------------------------------------------------------------

# Find the worktree path for a given branch (if any)
# Returns empty string if no worktree exists for the branch
find_worktree_for_branch() {
    local branch="$1"
    local repo_dir="$2"
    # Parse "git worktree list --porcelain" output:
    #   worktree /path/to/worktree    (10 chars before path)
    #   branch refs/heads/branchname  (19 chars before branch name)
    git -C "$repo_dir" worktree list --porcelain 2>/dev/null | \
        awk -v branch="$branch" '
            /^worktree / { wt = substr($0, 10) }
            /^branch refs\/heads\// {
                b = substr($0, 19)
                if (b == branch) print wt
            }
        '
}

do_sync() {
    require_brancher_workspace

    info "Validating sync prerequisites..."

    # --------------------------------------------------------------------------
    # Phase 1: Pre-validation (no changes made)
    # --------------------------------------------------------------------------

    # Check 1: Current workspace must be clean (untracked files are OK)
    if has_uncommitted_changes; then
        die "workspace has uncommitted changes; please commit or stash before syncing."
    fi

    # Check 2: Find parent worktree and ensure it has no uncommitted changes
    # Note: Untracked files (??) are OK - only block on staged/modified tracked files
    local parent_worktree
    parent_worktree="$(find_worktree_for_branch "$PARENT_BRANCH" "$PARENT_REPO_ROOT")"
    if [[ -n "$parent_worktree" ]] && has_uncommitted_changes "$parent_worktree"; then
        die "parent worktree (${parent_worktree}) has uncommitted changes; please commit or stash before syncing."
    fi

    # Check 3: Compute merge status
    local merge_base current_head parent_head
    merge_base="$(git merge-base HEAD "$PARENT_BRANCH" 2>/dev/null)" || die "cannot find common ancestor with '$PARENT_BRANCH'."
    current_head="$(git rev-parse HEAD)"
    parent_head="$(git rev-parse "$PARENT_BRANCH")"

    # Determine what needs to happen
    local need_merge_parent=false    # parent has commits we don't have
    local need_update_parent=false   # we have commits parent doesn't have

    if [[ "$merge_base" != "$parent_head" ]]; then
        need_merge_parent=true
    fi
    if [[ "$merge_base" != "$current_head" ]]; then
        need_update_parent=true
    fi

    # Already in sync
    if [[ "$need_merge_parent" == "false" && "$need_update_parent" == "false" ]]; then
        success "Already in sync with ${CYAN}${PARENT_BRANCH}${RESET}"
        return 0
    fi

    # Check 4: If we need to merge parent's changes, verify no conflicts
    if [[ "$need_merge_parent" == "true" ]]; then
        info "Checking for merge conflicts..."
        # Try merge in-memory using git merge-tree (available in git 2.38+)
        if git merge-tree --write-tree HEAD "$PARENT_BRANCH" >/dev/null 2>&1; then
            : # Merge would succeed
        else
            # Fallback: try actual merge with --no-commit, then abort
            if ! git merge --no-commit --no-ff "$PARENT_BRANCH" >/dev/null 2>&1; then
                git merge --abort 2>/dev/null || true
                die "merge would have conflicts; please resolve manually with 'git merge $PARENT_BRANCH'."
            fi
            git merge --abort 2>/dev/null || true
        fi
    fi

    success "Pre-validation passed"

    # --------------------------------------------------------------------------
    # Phase 2: Sync (make changes)
    # --------------------------------------------------------------------------

    # Step A: Merge parent → current (if parent has new commits)
    if [[ "$need_merge_parent" == "true" ]]; then
        info "Merging ${CYAN}${PARENT_BRANCH}${RESET} → ${CYAN}${BRANCH_NAME}${RESET}..."
        if ! git_quiet merge "$PARENT_BRANCH" --no-edit; then
            git merge --abort 2>/dev/null || true
            die "merge failed unexpectedly; please resolve manually."
        fi
    fi

    # Step B: Fast-forward parent to current (if we have new commits)
    # After the merge above, current branch has everything, so parent can ff
    if [[ "$need_update_parent" == "true" ]]; then
        info "Updating ${CYAN}${PARENT_BRANCH}${RESET} ← ${CYAN}${BRANCH_NAME}${RESET}..."

        # Update the parent branch ref to point to our current HEAD
        local new_head
        new_head="$(git rev-parse HEAD)"
        if ! git_silent update-ref "refs/heads/$PARENT_BRANCH" "$new_head"; then
            die "failed to update '$PARENT_BRANCH' branch."
        fi

        # If parent has a worktree, update it to reflect the new state
        if [[ -n "$parent_worktree" ]]; then
            info "Updating parent worktree..."
            # Reset the parent worktree to match the updated branch
            if ! git -C "$parent_worktree" reset --hard HEAD >/dev/null 2>&1; then
                warn "Could not update parent worktree; you may need to run 'git reset --hard' in ${parent_worktree}"
            fi
        fi
    fi

    success "Synced ${CYAN}${BRANCH_NAME}${RESET} ↔ ${CYAN}${PARENT_BRANCH}${RESET}"
}

# ------------------------------------------------------------------------------
# brancher close
# ------------------------------------------------------------------------------
#
# WHAT CLOSE DOES:
#   Merges any new commits back to parent, then cleans up the workspace.
#   Returns you to the parent repo directory (where you ran 'brancher open').
#
# WORKFLOW:
#   1. Check workspace is clean (no uncommitted changes)
#   2. If there are new commits on this branch:
#      - Merge them into parent branch
#   3. Remove the worktree and delete the branch
#   4. Output "cd '/path/to/parent/repo'" to stdout
#
# IMPORTANT:
#   The cd command is output to stdout. The shell wrapper function (see top
#   of this file) must eval this command to actually change directories.
#   If you see "cd '/path'" printed instead of changing dirs, you're likely
#   calling the script directly instead of through the wrapper function.
#
# ------------------------------------------------------------------------------

do_close() {
    require_brancher_workspace

    # Check for uncommitted changes (untracked files are OK)
    if has_uncommitted_changes; then
        die "workspace has uncommitted changes; please commit or stash before closing."
    fi

    # Get current HEAD
    local current_commit
    current_commit="$(git rev-parse HEAD)"

    # Sync with parent branch first (pull latest changes)
    # Only sync if parent repo is clean (untracked files OK); otherwise just proceed with close
    if ! has_uncommitted_changes "$PARENT_REPO_ROOT"; then
        # Fetch and pull parent branch if it has upstream
        if git -C "$PARENT_REPO_ROOT" remote | grep -q .; then
            git -C "$PARENT_REPO_ROOT" fetch origin 2>/dev/null || true
        fi
        if git -C "$PARENT_REPO_ROOT" rev-parse --abbrev-ref "$PARENT_BRANCH@{upstream}" >/dev/null 2>&1; then
            local original_branch
            original_branch="$(git -C "$PARENT_REPO_ROOT" rev-parse --abbrev-ref HEAD)"
            if git_silent -C "$PARENT_REPO_ROOT" checkout "$PARENT_BRANCH"; then
                git_silent -C "$PARENT_REPO_ROOT" pull --ff-only || true
                # Return to original branch if different
                if [[ "$original_branch" != "$PARENT_BRANCH" ]]; then
                    git_silent -C "$PARENT_REPO_ROOT" checkout "$original_branch" || true
                fi
            fi
        fi

        # Merge parent into workspace to ensure we're up to date
        if ! git_quiet merge "$PARENT_BRANCH" --no-edit; then
            git merge --abort 2>/dev/null || true
            die "merge of '$PARENT_BRANCH' into '$BRANCH_NAME' has conflicts; please resolve manually before closing."
        fi

        # Update current_commit after potential merge
        current_commit="$(git rev-parse HEAD)"
    fi

    # Determine if there are new commits (compared to start_commit)
    local has_new_commits=false
    if [[ "$current_commit" != "$START_COMMIT" ]]; then
        has_new_commits=true
    fi

    if [[ "$has_new_commits" == "true" ]]; then
        # Case B: There are new commits - need to merge back to parent

        # Check parent repo is clean (untracked files are OK)
        if has_uncommitted_changes "$PARENT_REPO_ROOT"; then
            die "parent repo has uncommitted changes; please commit or stash before closing."
        fi

        # Checkout parent branch in parent repo
        if ! git_silent -C "$PARENT_REPO_ROOT" checkout "$PARENT_BRANCH"; then
            die "failed to checkout '$PARENT_BRANCH' in parent repo."
        fi

        # Attempt merge
        if ! git_quiet -C "$PARENT_REPO_ROOT" merge --ff-only "$BRANCH_NAME"; then
            # Try regular merge
            if ! git_quiet -C "$PARENT_REPO_ROOT" merge --no-edit "$BRANCH_NAME"; then
                # Merge failed, abort it
                git -C "$PARENT_REPO_ROOT" merge --abort 2>/dev/null || true
                die "merge of '$BRANCH_NAME' into '$PARENT_BRANCH' is not clean; please resolve manually."
            fi
        fi

        success "Merged ${CYAN}${BRANCH_NAME}${RESET} into ${CYAN}${PARENT_BRANCH}${RESET}"
    else
        # Case A: No new commits
        info "No new commits on branch ${CYAN}${BRANCH_NAME}${RESET}"
    fi

    # We need to leave the workspace directory before removing it
    # First, cd to parent repo (where we originally ran 'brancher open')
    cd "$PARENT_REPO_ROOT"

    # Remove the worktree from parent repo
    info "Cleaning up workspace..."
    git_silent worktree remove "$WORKSPACE_ROOT" --force || true

    # Delete the branch from parent repo
    git_silent branch -D "$BRANCH_NAME" || true

    # Remove workspace directory if it still exists (belt and suspenders)
    if [[ -d "$WORKSPACE_ROOT" ]]; then
        rm -rf "$WORKSPACE_ROOT"
    fi

    # tmux: reset pane title
    tmux_set_pane_title ""

    # User feedback
    if [[ "$has_new_commits" == "true" ]]; then
        success "Closed ${CYAN}${BRANCH_NAME}${RESET} → merged into ${CYAN}${PARENT_BRANCH}${RESET}"
    else
        success "Closed ${CYAN}${BRANCH_NAME}${RESET} (no changes)"
    fi
    info "Back to: ${BOLD}${PARENT_REPO_ROOT}${RESET}"

    # Output cd command - return to the original repo where 'brancher open' was run
    output_cd "$PARENT_REPO_ROOT"
}

# ------------------------------------------------------------------------------
# Main
# ------------------------------------------------------------------------------

main() {
    local subcommand="${1:-}"

    case "$subcommand" in
        open)
            shift
            if [[ $# -ne 1 ]]; then
                echo "Error: 'brancher open' requires exactly one argument (branch name)." >&2
                usage
            fi
            do_open "$1"
            ;;
        sync)
            shift
            if [[ $# -ne 0 ]]; then
                echo "Error: 'brancher sync' takes no arguments." >&2
                usage
            fi
            do_sync
            ;;
        close)
            shift
            if [[ $# -ne 0 ]]; then
                echo "Error: 'brancher close' takes no arguments." >&2
                usage
            fi
            do_close
            ;;
        -h|--help|help)
            usage
            ;;
        "")
            echo "Error: missing subcommand." >&2
            usage
            ;;
        *)
            echo "Error: unknown subcommand '$subcommand'." >&2
            usage
            ;;
    esac
}

main "$@"
